<html>

<head>
  <meta charset="UTF-8">
  <style>
    body {
      background-color: #202020;
      color: #ffffff;
      font-size: 1.5em;
      font-weight: 400;
      font-family: "";
    }

    /* To change background color or text color, just replace the style values above with the hex values for the colors you want.
    To change font size, just change the em value to what works for you (the standard size is 1, I like it at 1.5).
    To change font weight (boldness), just edit the value above.  100 is quite thin, 400 is default, 900 is quite thick.  You may want it higher than default for Mincho fonts.
    
    To change the font itself, put the ENGLISH name of your font in between the quotation marks above (some JP font names are in Japanese, such as "�O�����؊G��").
    To find the English name of a given font, first install it, then open Firefox.
    Go to about:preferences#content in the address bar, then click on the 'Default font' drop-down menu.
    The "correct" name of your font will be listed here - just copy that down and paste it up above.
    
    Note that if you are fine with whatever font you have now then you can just leave the quotation marks above blank and the default font will be used.
    Your default is probably Gothic - if you want to try out a good Mincho font, try Aozora Mincho at http://www.freejapanesefont.com/aozora-mincho-download/
    For various other free Japanese fonts, visit http://www.freejapanesefont.com/
    For more font attribute information visit http://www.w3schools.com/css/css_font.asp */

    p,
    div {
      margin-top: 1em;
    }
  </style>
</head>

<body>
  <script>
    /* Fun Stuff that you need to copy into your page */

    /**
     * https://translate.google.com/translate/releases/twsfe_w_20160620_RC00/r/js/desktop_module_main.js
     *
     * Everything between 'BEGIN' and 'END' was reverse engineered from the url above.
     */

    // BEGIN

    const translationKey = (text) => {
      const obfuscate = (keyGenerator, obfuscationArray) => {
        for (let i = 0; i < obfuscationArray.length - 2; i += 3) {
          let j = obfuscationArray[i + 2];
          j = "a" <= j ? j.charCodeAt(0) - 87 : Number(j);
          j = "+" === obfuscationArray[i + 1] ? keyGenerator >>> j : keyGenerator << j;
          keyGenerator = "+" === obfuscationArray[i] ? keyGenerator + j : keyGenerator ^ j;
        }
        return keyGenerator;
      };
      let keyGenerationArray = [];
      for (let i = 0, j = 0; j < text.length; j++) {
        let k = text.charCodeAt(j);
        if (k < 128) {
          keyGenerationArray[i++] = k;
        } else {
          if (k < 2048) {
            keyGenerationArray[i++] = k >> 6 | 0xC0;
          } else {
            if (0xD800 === (k & 0xFC00) && j + 1 < text.length && 0xDC00 === (text.charCodeAt(j + 1) & 0xFC00)) {
              k = 0x10000 + ((k & 0x3FF) << 10) + (text.charCodeAt(++j) & 0x3FF);
              keyGenerationArray[i++] = k >> 18 | 0xF0;
              keyGenerationArray[i++] = k >> 12 & 0x3F | 0x80;
            }
            else {
              keyGenerationArray[i++] = k >> 12 | 0xE0;
            }
            keyGenerationArray[i++] = k >> 6 & 0x3F | 0x80;
          }
          keyGenerationArray[i++] = k & 0x3F | 0x80;
        }
      }
      const translationKeySeed = TKK.split(".").map(v => +v);
      let keyGenerator = translationKeySeed[0];
      for (let i = 0; i < keyGenerationArray.length; i++) {
        keyGenerator += keyGenerationArray[i];
        keyGenerator = obfuscate(keyGenerator, ["+", "-", "a", "^", "+", "6"]);
      }
      keyGenerator = obfuscate(keyGenerator, ["+", "-", "3", "^", "+", "b", "+", "-", "f"]);
      keyGenerator ^= translationKeySeed[1];
      if (keyGenerator < 0) {
        keyGenerator = (keyGenerator & 0x7FFFFFFF) + 0x80000000;
      }
      keyGenerator %= 1e6;
      return "&tk=" + keyGenerator + "." + (keyGenerator ^ translationKeySeed[0]);
    };

    // END

    const updateTKK = () =>
      new Promise(
        resolve =>
          Number(window.TKK && window.TKK.split(".")[0]) === Math.floor(Date.now() / 3600000)
            ? resolve()
            : fetch("https://crossorigin.me/https://translate.google.com")
              .then(resp => resp.text())
              .then(text => {
                const code = text.match(/TKK=(.*?)\(\)\)'\);/g);
                if (code) {
                  eval(code[0]);
                }
                resolve();
              })
      );

    const translate = text =>
      new Promise(resolve =>
        updateTKK().then(() =>
          fetch(
            "https://crossorigin.me/https://translate.google.com/translate_a/single?client=t&dt=ld&dt=rm&dt=t" +
            translationKey(text) +
            "&q=" +
            encodeURIComponent(text)
          )
            .then(resp => resp.json())
            .then(data => resolve(data[0].filter(v => v[0]).map(v => v[0]).join(" ")))
        )
      );


    const b = document.body;
    new MutationObserver(mutations => {
      const node = mutations[0].addedNodes[0];
      if (b.scrollTop - b.offsetHeight >= -b.clientHeight - b.scrollHeight + b.offsetHeight - 100) {
        window.scrollTo(0, b.scrollHeight);
      }
      if (node.tagName === "P") {
        translate(node.innerHTML).then(translation =>
          window.autoTranslate
            ? b.appendChild(document.createElement("div")).textContent = translation
            : node.addEventListener("dblclick", () =>
              b.appendChild(document.createElement("div")).textContent = translation
            )
        );
      }
    }).observe(b, { childList: true });

    Object.defineProperty(window, "toggleAutoTranslate", { get: () => window.autoTranslate = !window.autoTranslate });

  /* End of the Fun Stuff */
  </script>
</body>

</html>